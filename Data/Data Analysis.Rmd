---
title: "Data Analysis"
author: "Ina Liao"
date: "2024-02-05"
output: pdf_document
---


```{r Setup, include=FALSE}
knitr:::opts_chunk$set(tidy.opts=list(width.cutoff=80), tidy=FALSE,fig.align = "center", dev = "cairo_pdf", fig.pos = "H")
```

```{r Install packages, message=FALSE}
#install.packages("lubridate")
#install.packages("ggplot2")
#install.packages("forecast")
#install.packages("here")
#install.packages("knitr")
#install.packages("kableExtra")
#install.packages("dplyr")
#install.packages("openxlsx")
#install.packages("ggthemes")
#install.packages("tidyr")
#install.packages("GGally")
#install.packages("Kendall")
#install.packages("tseries")
#install.packages("blorr")
#install.packages("car")
#install.packages("corrplot")
#install.packages("dlm")
#install.packages("randomForest")
library(lubridate)
library(ggplot2)
library(forecast) 
library(here)
library(knitr)
library(kableExtra)
library(dplyr)
library(openxlsx)
library(ggthemes)
library(tidyr)
library(GGally)
library(trend)
library(tseries)
library(blorr)   
library(lmtest) 
library(car)
library(cowplot)
library(corrplot)
library(dlm)
library(randomForest)
library(e1071) 
library(Kendall)
```

```{r Import Data, echo=TRUE, results='hide'}
here()
raw_data<-read.csv(here('Data/Processed/Load_weather.csv'),stringsAsFactors = TRUE,skip=0,header=TRUE)
df<-raw_data[,2:15]
head(raw_data)
```
```{r Set Plot Theme}
my_plot_theme<- theme_calc()+
  theme(
    #plot background
    plot.background = element_rect(color="gray"),
    
    #plot title
    plot.title=element_text(color="black",hjust=0.5,vjust=1),
    
    #axis labels
    axis.title.x = element_text(size = 8),
    axis.title.y = element_text(size = 8),
    
    #gridlines 
    panel.grid.major=element_line("white"),
    panel.grid.minor = element_line("white"),
    axis.ticks=element_line(color="gray"),
    
    #legend 
    legend.key=element_rect(color="white"),
    legend.background = element_rect(color="white"),
    legend.text = element_text(size = 8),
    legend.position="right"
      )
theme_set(my_plot_theme)
```




```{r Time Series Object - TS}
ts_all<-ts(df[,5:14], start=c(2015,07),frequency=365) 
#do not specify end=c(2022,12)

#electricity 
plot_ts_electricity<-autoplot(ts_all[,6:10])+
  labs(y="electicity (MWh)")
plot_ts_electricity

#weather
plot_ts_weather<-autoplot(ts_all[,1:5])
plot_ts_weather 
#this plot does not have any meaning given that the unit of the variables are different
```

```{r Time Series Object - MSTS}
#msts
msts_all<-msts(df[,5:14], seasonal.periods=c(7,365), start=c(2015,07,01))
#account for two seasonal periods 
#,end=c(2022,12,31)
#is using hourly data: seasonal periods=c(7, 168, 8760)


#electricity 
autoplot(msts_all[,6],series="Demand Forecast")+
  autolayer(msts_all[,7],series="Actual Demand")+
  labs(y="electicity (MWh)",title="Demand Forecast and Actual Demand")


#weather
head(msts_all)
par(mfrow=c(2,2))
autoplot(msts_all[,1])+labs(title="Dew Point",y="°C Td")
autoplot(msts_all[,2])+labs(title="Wind Speed",y="m/s")
autoplot(msts_all[,3])+
  labs(title="Temperature",y="°C")+
  geom_hline(yintercept = 18, linetype = "dashed", color = "blue")
autoplot(msts_all[,5],series="CDD")+
  autolayer(msts_all[,4],series="HDD")+
  labs(y="°C")

```

```{r ACF and PACF}
#msts
for(i in 1:7){ 
  par(mfrow=c(1,2))
  Acf(msts_all[,i],lag.max=40,main=paste("ACF for",colnames(df[i+4]),sep=" "),ylim=c(-0.5,1))
  Pacf(msts_all[,i],lag.max=40,main=paste("PACF for",colnames(df[i+4]),sep=" "),ylim=c(-0.5,1))
}


#ts
for(i in 1:10){ 
  par(mfrow=c(1,2))
  Acf(ts_all[,i],lag.max=40,main=paste("ACF for",colnames(df[i+4]),sep=" "),ylim=c(-0.5,1))
  Pacf(ts_all[,i],lag.max=40,main=paste("PACF for",colnames(df[i+4]),sep=" "),ylim=c(-0.5,1))
}
```
```{r Detrand and deseason}
#decompose 
demand_decompose<-decompose(msts_all[,7],type="additive")
plot_demand_decompose<-plot(demand_decompose)

#deseason
demand_deseason<- seasadj(demand_decompose)

#plot
par(mfrow=c(1,2))
Acf(demand_deseason,lag=40,main=paste("ACF for deseason demand"),ylim=c(-0.5,1))
Pacf(demand_deseason,lag=40,main=paste("PACF for deseason demand"),ylim=c(-0.5,1))

#plot_grid(
  #autoplot(Acf(msts_all[,7],lag=40,plot=FALSE),main="Original Electricity Demand"),
  #autoplot(Pacf(msts_all[,7],lag=40,plot=FALSE),main="Original Electricity Demand"),
  #nrow=2)
```

 

```{r Monthly data}
standard_temp<-(65-32)*(5/9)

#creat monthly dataframe 
df_monthly<-df %>%
  group_by(month) %>%
  summarize(dew_point=mean(dew_point,na.rm=TRUE),
            wind_speed=mean(wind_speed,na.rm=TRUE),
            temperature=mean(temperature,na.rm=TRUE),
            demand_forecast=mean(demand_forecast, na.rm=TRUE),
            demand=mean(demand, na.rm=TRUE),
            net_generation=mean(net_generation, na.rm=TRUE),
            total_interchange=mean(total_interchange, na.rm=TRUE),
            ) %>%
  mutate(hdd=ifelse(temperature>standard_temp, temperature-standard_temp,0),
         cdd=ifelse(temperature<standard_temp, standard_temp-temperature,0)) 

#change the column order
df_monthly<-df_monthly[,c(1:3,9:10,4:8)]

#create monthly time series object
ts_monthly_all<-ts(df_monthly[,2:10], start=c(2015,07),end=c(2022,12),frequency=12) 
```

```{r Stationary test}
#Mann-Kendall
summary(MannKendall(ts_all[,7])) #reject the null hypothesis, supporting the presence of a trend

head(ts_monthly_all)
#seasonal Mann-Kendall
#question
#use monthly data for smk 
for(i in 1:9){
  summary(trend::smk.test(ts_monthly_all[,i]))
}

#ADF test
for(i in 1:10){
  print(adf.test(ts_all[,i],alternative = "stationary"))
}
```

```{r Differencing}
#find out how many times for differencing
ns_diff<-nsdiffs(ts_all[,7])
cat("Number of seasonal differencing needed:", ns_diff)
#the series does not need to be differenced

```

```{r Outliers}
clean_demand<-tsclean(ts_monthly_all[,7])
plot_demand<-autoplot(clean_demand, series="Demand Clean") +
  autolayer(ts_monthly_all[,7], series="Demand raw") +
  labs(title="Electricity Demand")+
  ylab("Electricity (MWh)")
plot_demand
```

```{r Multilinear Regression}
#use temperature to represent hdd and cdd
model_all<-lm(demand~wind_speed+dew_point+weekday_weekend+temperature,data=df)
summary(model_all)
#linear regression: can we assume that independent variables are normally distributed
```

```{r Residuals vs fitted}
vif(model_all)
```

```{r Correlation Test - Demand}
#demand and exogenous variable
#correlation test 
cor_demand_wind<-cor.test(df$demand,df$wind_speed,method = "spearman",exact = FALSE)
cor_demand_dew<-cor.test(df$demand,df$dew_point,method = "spearman",exact = FALSE)
cor_demand_weekend<-cor.test(df$demand,df$weekday_weekend,method = "spearman",exact = FALSE)
cor_demand_temp<-cor.test(df$demand,df$temperature,method = "spearman",exact = FALSE)

#create a summary table 
summary_table_cor_dem<-data.frame(
  Variable = c("Wind Speed", "Dew Point", "Weekday/Weekend", "Temperature"),
  Correlation_Coefficient = round(c(cor_demand_wind$estimate, 
                                    cor_demand_dew$estimate,
                                    cor_demand_weekend$estimate,
                                    cor_demand_temp$estimate), 5),
  P_Value = round(c(cor_demand_wind$p.value, 
                    cor_demand_dew$p.value, 
                    cor_demand_weekend$p.value, 
                    cor_demand_temp$p.value), 5)
)

print(summary_table_cor_dem)

```

```{r Correlation Test - Forecast error}
#demand and exogenous variable
#correlation test 
cor_err_wind<-cor.test(df$forecast_error,df$wind_speed,method = "spearman",exact = FALSE)
cor_err_dew<-cor.test(df$forecast_error,df$dew_point,method = "spearman",exact = FALSE)
cor_err_weekend<-cor.test(df$forecast_error,df$weekday_weekend,method = "spearman",exact = FALSE)
cor_err_temp<-cor.test(df$forecast_error,df$temperature,method = "spearman",exact = FALSE)

#create a summary table 
summary_table_cor_err<-data.frame(
  Variable = c("Wind Speed", "Dew Point", "Weekday/Weekend", "Temperature"),
  Correlation_Coefficient = round(c(cor_err_wind$estimate, 
                                    cor_err_dew$estimate,
                                    cor_err_weekend$estimate,
                                    cor_err_temp$estimate), 5),
  P_Value = round(c(cor_err_wind$p.value, 
                    cor_err_dew$p.value, 
                    cor_err_weekend$p.value, 
                    cor_err_temp$p.value), 5)
)

print(summary_table_cor_err)

```

```{r Correlation Metrix}
#build the subset dataset containing demand and exogenous variables 
df_sub<-df[,c(4:7,11)]
correlation_matrix<-cor(df_sub)
corrplot(correlation_matrix,method="color",
         tl.col = "black",
         tl.cex = 0.7,
         mar = c(0,0,1,0),
         order = "AOE")

df_sub_err<-df[,c(4:7,10)]
correlation_matrix_err<-cor(df_sub_err)
corrplot(correlation_matrix_err,method="color",
         tl.col = "black",
         tl.cex = 0.7,
         mar = c(0,0,1,0),
         order = "AOE")
```

```{r Training and Testing Data}
#original series
#training 
#msts_training<-msts(df[,11], seasonal.periods=c(7,365),
                   #start=c(2015,07,01),end=c(2020,12,31))
nobs <- nrow(df[,11])
nfor <- 365*2

msts_training<-subset(msts_all[,7], end=length(msts_all[,7])-nfor)
msts_testing<-subset(msts_all[,7], start=length(msts_all[,7])-nfor+1)

#testing
#msts_testing<-msts(df[,11], seasonal.periods=c(7,365),
                   #start=c(2021,01,01),end=c(2022,12,31))

#deseason series

#msts_deseason_training<-msts(demand_deseason, seasonal.periods=c(7,365),
                   #start=c(2015,07,01),end=c(2020,12,31))

#testing
#msts_deseason_testing<-msts(demand_deseason, seasonal.periods=c(7,365),
                   #start=c(2021,01,01),end=c(2022,12,31))


#demand
autoplot(msts_training)
autoplot(msts_testing)

```
#assuming a forecasting horizon of two years

```{r ETS}
ETS_fit<-stlf(msts_training, h=365*2)
```

```{r ARIMA and FOURIER terms}
#K=c(2,4)
#fit ARIMA with original time series 
#ARIMA_Four_fit_1<-auto.arima(msts_deseason_training,
                           #seasonal=FALSE, #because ARIMA can not handle seasonality 
                           #xreg=fourier(msts_training,K=c(2,4)))
#forecast with ARIMA_fit
#ARIMA_Four_forecast_1<-forecast(ARIMA_Four_fit_1,
                              #xreg=fourier(msts_deseason_training,K=c(2,4),h=365*2),
                              #h=365*2) 


ARIMA_Four_fit_1<-auto.arima(msts_training,
                           seasonal=FALSE, #because ARIMA can not handle seasonality 
                           xreg=fourier(msts_training,K=c(2,4)))
#forecast with ARIMA_fit
ARIMA_Four_forecast_1<-forecast(ARIMA_Four_fit_1,
                              xreg=fourier(msts_training,K=c(2,4),h=365*2),
                              h=365*2) 


#K=c(2,12)
#fit ARIMA with original time series 
ARIMA_Four_fit_2<-auto.arima(msts_training,
                           seasonal=FALSE, 
                           xreg=fourier(msts_training,K=c(2,12)))
#forecast with ARIMA_fit
ARIMA_Four_forecast_2<-forecast(ARIMA_Four_fit_2,
                                xreg=fourier(msts_training,K=c(2,12),h=365*2),
                                h=365*2) 
```

```{r ARIMA + Fourie + exogenous variable}
#temperature and demand has the highest correlation
head(msts_all)

#all variables have the same time frame
#temperature has the highest correlation
#msts_temp_training<-msts(df[,7], seasonal.periods=c(7,365),
                   #start=c(2015,07,01),end=c(2020,12,31))

#msts_temp_testing<-msts(df[,7], seasonal.periods=c(7,365),
                   #start=c(2021,01,01),end=c(2022,12,31))



msts_temp_training<-subset(msts_all[,3], end=length(msts_all[,7])-nfor)
msts_temp_testing<-subset(msts_all[,3], start=length(msts_all[,7])-nfor+1)


#K=c(2,4)
#fit ARIMA with original time series 
#ARIMA_Four_fit_XREG_1<-auto.arima(msts_deseason_training,
                         #  seasonal=FALSE,
                           #combine fourier and exogenous variable time series  
                        #   xreg=as.matrix(cbind(fourier(msts_deseason_training,K=c(2,4)),
                                          #      msts_temp_training)))  

#generate fourier terms
#fourier_terms_1<-fourier(msts_deseason_training, K=c(2,4), h = 365*2)
#generate forecast
#temp_forecast_1<-forecast(msts_temp_training, h = 365*2)
#combine fourier terms and forecasts into a numeric matrix
#xreg_matrix_1<-as.matrix(cbind(fourier_terms_1, temp_forecast_1$mean))

#forecast with ARIMA_fit_XREG
#ARIMA_Four_forecast_XREG_1<-forecast(ARIMA_Four_fit_XREG_1,
                                  # xreg = xreg_matrix_1,
                                  # h = 365*2)


#fit ARIMA with original time series 
ARIMA_Four_fit_XREG_1<-auto.arima(msts_training,
                           seasonal=FALSE,
                           #combine fourier and exogenous variable time series  
                           xreg=as.matrix(cbind(fourier(msts_training,K=c(2,4)),
                                                msts_temp_training)))  

#generate fourier terms
fourier_terms_1<-fourier(msts_training, K=c(2,4), h = 365*2)
#generate forecast
temp_forecast_1<-forecast(msts_temp_training, h = 365*2)
#combine fourier terms and forecasts into a numeric matrix
xreg_matrix_1<-as.matrix(cbind(fourier_terms_1, temp_forecast_1$mean))

#forecast with ARIMA_fit_XREG
ARIMA_Four_forecast_XREG_1<-forecast(ARIMA_Four_fit_XREG_1,
                                   xreg = xreg_matrix_1,
                                   h = 365*2)

#K=c(2,12)
#fit ARIMA with original time series 
ARIMA_Four_fit_XREG_2<-auto.arima(msts_training,
                           seasonal=FALSE,
                           #combine fourier and exogenous variable time series  
                           xreg=as.matrix(cbind(fourier(msts_training,K=c(2,12)),
                                                msts_temp_training)))  

#generate fourier terms
fourier_terms_2<-fourier(msts_training, K=c(2,12), h = 365*2)
#generate forecast
temp_forecast_2<-forecast(msts_temp_training, h = 365*2)
#combine fourier terms and forecasts into a numeric matrix
xreg_matrix_2<-as.matrix(cbind(fourier_terms_2, temp_forecast_2$mean))

#forecast with ARIMA_fit_XREG
ARIMA_Four_forecast_XREG_2<-forecast(ARIMA_Four_fit_XREG_2,
                                   xreg = xreg_matrix_2,
                                   h = 365*2)

```


```{r Neural Network}
#p=1, P=0 because seasonal=FALSE
#can exogenous variable also be included? 


#K=c(2,4)
#NN_fit_1<-nnetar(msts_deseason_training,
               #  p=1,
               #  P=0,
               #  xreg=fourier(msts_deseason_training,K=c(2,4)))

#NN_forecast_1<-forecast(NN_fit_1,
                       # xreg=fourier(msts_deseason_training,K=c(2,4),h=365*2), 
                       # h=365*2)

NN_fit_1<-nnetar(msts_training,
                 p=1,
                 P=0,
                 xreg=fourier(msts_training,K=c(2,4)))

NN_forecast_1<-forecast(NN_fit_1,
                        xreg=fourier(msts_training,K=c(2,4),h=365*2), 
                        h=365*2)

#K=c(2,12)
NN_fit_2<-nnetar(msts_training,
                 p=1,
                 P=0,
                 xreg=fourier(msts_training,K=c(2,12)))

NN_forecast_2<-forecast(NN_fit_2,
                        xreg=fourier(msts_training,K=c(2,12),h=365*2), 
                        h=365*2)
```

```{r Neural Network + XREG}
#K=c(2,4)
#NN_fit_XREG_1<-nnetar(msts_deseason_training,
                 #p=1,
                 #P=0,
                 #xreg=as.matrix(cbind(fourier(msts_deseason_training,K=c(2,4)),
                                     # msts_temp_training)))

#generate fourier terms
#fourier_terms_NN_1<-fourier(msts_deseason_training, K=c(2,4), h = 365*2)
#generate forecast
#temp_forecast_NN_1<-forecast(msts_temp_training, h = 365*2)
#combine fourier terms and forecasts into a numeric matrix
#xreg_matrix_NN_1<-as.matrix(cbind(fourier_terms_NN_1, temp_forecast_NN_1$mean))

#NN_forecast_XREG_1<-forecast(NN_fit_XREG_1,
                           #  xreg=xreg_matrix_NN_1, 
                           #  h=365*2)


NN_fit_XREG_1<-nnetar(msts_training,
                 p=1,
                 P=0,
                 xreg=as.matrix(cbind(fourier(msts_training,K=c(2,4)),
                                      msts_temp_training)))

#generate fourier terms
fourier_terms_NN_1<-fourier(msts_training, K=c(2,4), h = 365*2)
#generate forecast
temp_forecast_NN_1<-forecast(msts_temp_training, h = 365*2)
#combine fourier terms and forecasts into a numeric matrix
xreg_matrix_NN_1<-as.matrix(cbind(fourier_terms_NN_1, temp_forecast_NN_1$mean))

NN_forecast_XREG_1<-forecast(NN_fit_XREG_1,
                             xreg=xreg_matrix_NN_1, 
                             h=365*2)



#K=c(2,12)
NN_fit_XREG_2<-nnetar(msts_training,
                 p=1,
                 P=0,
                 xreg=as.matrix(cbind(fourier(msts_training,K=c(2,12)),
                                      msts_temp_training)))

#generate fourier terms
fourier_terms_NN_2<-fourier(msts_training, K=c(2,12), h = 365*2)
#generate forecast
temp_forecast_NN_2<-forecast(msts_temp_training, h = 365*2)
#combine fourier terms and forecasts into a numeric matrix
xreg_matrix_NN_2<-as.matrix(cbind(fourier_terms_NN_2, temp_forecast_NN_2$mean))

NN_forecast_XREG_2<-forecast(NN_fit_XREG_2,
                             xreg=xreg_matrix_NN_2, 
                             h=365*2)
```

```{r Plot Forecast Results}
#filter the original time series data to include only the forecast period
forecast_start<-start(ARIMA_Four_forecast_1$mean)
forecast_end<-end(ARIMA_Four_forecast_1$mean)
msts_forecast<-window(msts_all[,7],start = forecast_start,end = forecast_end)
head(msts_all)


#add the seasonality back 
#ETS_fit$mean<-ETS_fit$mean+demand_decompose$seasonal
#ARIMA_Four_forecast_1$mean<-ARIMA_Four_forecast_1$mean+demand_decompose$seasonal
#ARIMA_Four_forecast_XREG_1$mean<-ARIMA_Four_forecast_XREG_1$mean+demand_decompose$seasonal
#NN_forecast_1$mean<-NN_forecast_1$mean+demand_decompose$seasonal
#NN_forecast_XREG_1$mean<-NN_forecast_XREG_1$mean+demand_decompose$seasonal


#plot forecasting result
#question
#K=c(2,4)
autoplot(msts_forecast) +
  autolayer(ETS_fit, series="STL + ETS",PI=FALSE)

autoplot(msts_forecast,ylim=c(-5000,15000)) +
  autolayer(ARIMA_Four_forecast_1, series="ARIMA Fourier, K=c(2,4)",PI=FALSE)+
  autolayer(ARIMA_Four_forecast_XREG_1, series="ARIMA Fourier XREG, K=c(2,4)",PI=FALSE)
  
autoplot(msts_forecast) +
  autolayer(NN_forecast_1, series="Neural Network, K=c(2,4)",ylim=c(-5000,15000))+
  autolayer(NN_forecast_XREG_1, series="Neural network + XREG, K=c(2,4)",ylim=c(-5000,15000))
  

#K=c(2,12)
autoplot(msts_forecast) +
  autolayer(ETS_fit, series="STL + ETS",PI=FALSE)

autoplot(msts_forecast) +
  autolayer(ARIMA_Four_forecast_2, series="ARIMA Fourier, K=c(2,12)",PI=FALSE)+
  autolayer(ARIMA_Four_forecast_XREG_2, series="ARIMA Fourier XREG, K=c(2,12)",PI=FALSE)
 #check: labs(ylim=c(-5000,15000))

autoplot(msts_forecast) +
  autolayer(NN_forecast_2, series="Neural Network, K=c(2,12)")+
  autolayer(NN_forecast_XREG_2, series="Neural network + XREG, K=c(2,12)")

```

```{r Model Residuals}
resi_ETS<-checkresiduals(ETS_fit)
resi_ARIMA_Four_1<-checkresiduals(ARIMA_Four_forecast_1)
resi_ARIMA_Four_2<-checkresiduals(ARIMA_Four_forecast_2)
resi_ARIMA_Four_XREG_1<-checkresiduals(ARIMA_Four_forecast_XREG_1)
resi_ARIMA_Four_XREG_2<-checkresiduals(ARIMA_Four_forecast_XREG_2)
resi_NN_forecast_1<-checkresiduals(NN_forecast_1)
resi_NN_forecast_2<-checkresiduals(NN_forecast_2)
resi_NN_forecast_XREG_1<-checkresiduals(NN_forecast_XREG_1)
resi_NN_forecast_XREG_2<-checkresiduals(NN_forecast_XREG_2)
```
```{r SS}

SS_ll <- StructTS(msts_training, type="level")
SS_llt <- StructTS(msts_training, type="trend")
SS_bsm <- StructTS(msts_training, type="BSM")

SS_ll_for <- forecast(SS_ll,h=nfor)
plot(SS_ll_for)


SS_llt_for <- forecast(SS_llt,h=nfor)
plot(SS_llt_for)


SS_bsm_for <- forecast(SS_bsm,h=nfor)
plot(SS_bsm_for)


```

```{r Accuracy}
#Model1:ETS
ETS_scores<-accuracy(ETS_fit$mean,msts_testing)

#SS
SS_llt_score <- accuracy(SS_llt_for$mean,msts_testing)
SS_bsm_score <- accuracy(SS_bsm_for$mean,msts_testing)
SS_ll_score <- accuracy(SS_ll_for$mean,msts_testing)


#Model2: ARIMA + Fourier, K=c(2,4) 
ARIMA_Four_forecast_scores_1<-accuracy(ARIMA_Four_forecast_1$mean,msts_testing)

#Model3: ARIMA + Fourier, K=c(2,12)
ARIMA_Four_forecast_scores_2<-accuracy(ARIMA_Four_forecast_2$mean,msts_testing)

#Model4: ARIMA + Fourier + exogenous variable, K=c(2,4)
ARIMA_Four_XREG_scores_1<-accuracy(ARIMA_Four_forecast_XREG_1$mean,msts_testing)

#Model5: ARIMA + Fourier + exogenous variable, K=c(2,12)
ARIMA_Four_XREG_scores_2<-accuracy(ARIMA_Four_forecast_XREG_2$mean,msts_testing)

#Model6: Neural network, K=c(2,4) 
NN_scores_1<-accuracy(NN_forecast_1$mean,msts_testing)

#Model7: Neural network, K=c(2,12)
NN_scores_2<-accuracy(NN_forecast_2$mean,msts_testing)

#Model8: Neural network + exogenous variable, K=c(2,4) 
NN_XREG_scores_1<-accuracy(NN_forecast_XREG_1$mean,msts_testing)

#Model9: Neural network + exogenous variable, K=c(2,12)
NN_XREG_scores_2<-accuracy(NN_forecast_XREG_2$mean,msts_testing)

#create a data frame to store the scores 
scores<-as.data.frame(rbind(ETS_scores,
                            SS_llt_score,
                            SS_bsm_score,
                            SS_ll_score,
                            ARIMA_Four_forecast_scores_1,
                            ARIMA_Four_forecast_scores_2,
                            ARIMA_Four_XREG_scores_1,
                            ARIMA_Four_XREG_scores_2,
                            NN_scores_1,
                            NN_scores_2,
                            NN_XREG_scores_1,
                            NN_XREG_scores_2))
row.names(scores)<-c("ETS",
                     "SS_LLT",
                     "SS_bsm",
                     "SS_ll",
                     "ARIMA+Fourier, K=c(2,4)",
                     "ARIMA+Fourier, K=c(2,12)",
                     "ARIMA+Fourier+XREG, K=c(2,4)",
                     "ARIMA+Fourier+XREG, K=c(2,12)",
                     "NN, K=c(2,4)",
                     "NN, K=c(2,12)",
                     "NN+XREG, K=c(2,4)",
                     "NN+XREG, K=c(2,12)")

#create a comparable table 
kbl(scores, 
    caption = "Forecast Accuracy for Electricity Demand (2021-2022)",
    digits = array(5,ncol(scores))) %>%
  kable_styling(full_width = FALSE, 
                position = "center", 
                latex_options = "hold_position")
```

```{r Neural Network Forecast - 1}
#best-performance model: NN, K=c(2,4) if using deseason series 
#best-performance model: NN, K=c(2,12) if using original time series

msts_demand_deseason<-msts(demand_deseason, seasonal.periods=c(7,365), start=c(2015,07,01))

#assuming a forecasting horizon of 15 years
NN_fit_all_1<-nnetar(msts_demand_deseason,
                   p=1,
                   P=0,
                   xreg=fourier(msts_demand_deseason,K=c(2,4)))

NN_forecast_all_1<-forecast(NN_fit_all_1,
                          xreg=fourier(msts_demand_deseason,K=c(2,4),h=365*15), 
                          h=365*15)

#add seasonality back
#question
NN_forecast_all_1$mean<-NN_forecast_all_1$mean+demand_decompose$seasonal

#add linear trend to prediction 
forecast_length<-length(NN_forecast_all_1$mean)
timeframe<-1:forecast_length
growth_slope<-0.11
linear_trend<-timeframe*growth_slope
NN_forecast_with_trend_1<-NN_forecast_all_1$mean + linear_trend




#plot
autoplot(msts_demand_deseason) +
  autolayer(NN_forecast_all_1$mean, series = "Original Forecast", color = "darkblue") +
  autolayer(NN_forecast_with_trend_1, series = "Forecast with Trend",color = "orange") +
  labs(title = "Original Time Series with Forecasted Series") +
  xlab("Time") +
  ylab("Electricity Demand (MWh)")
```

```{r Neural Network Forecast - 2}
#best-performance model: NN, K=c(2,4) if using deseason series 
#best-performance model: NN, K=c(2,12) if using original time series

#assuming a forecasting horizon of 15 years
NN_fit_all_2<-nnetar(msts_all[,7],
                   p=1,
                   P=0,
                   xreg=fourier(msts_all[,7],K=c(2,12)))

NN_forecast_all_2<-forecast(NN_fit_all_2,
                          xreg=fourier(msts_all[,7],K=c(2,12),h=365*15), 
                          h=365*15)

#add linear trend to prediction 
forecast_length<-length(NN_forecast_all_2$mean)
timeframe<-1:forecast_length
growth_slope<-0.11
linear_trend<-timeframe*growth_slope
NN_forecast_with_trend_2<-NN_forecast_all_2$mean + linear_trend

#plot
autoplot(msts_all[,7]) +
  autolayer(NN_forecast_all_2$mean, series = "Original Forecast", color = "darkblue") +
  autolayer(NN_forecast_with_trend_2, series = "Forecast with Trend", color = "orange") +
  labs(title = "Original Time Series with Forecasted Series") +
  xlab("Time") +
  ylab("Electricity Demand (MWh)")
```


